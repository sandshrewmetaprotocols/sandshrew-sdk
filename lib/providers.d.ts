type ProcessedPsbt = void;
type SignedTransaction = any;
type WalletInfo = any;
type BumpFeeResult = any;
type ValidatedAddress = any;
type BumpFeeOptions = any;
type BlockchainInfo = any;
type AddMultisigAddressResult = any;
type Block = any;
type BlockFilter = any;
type BlockHeader = any;
type BlockStats = any;
type ChainTip = any;
type ChainTxStats = any;
type MempoolAncestors = any;
type MempoolDescendants = any;
type MempoolEntry = any;
type MempoolInfo = any;
type RawMempool = any;
type RawTransaction = any;
type TestMempoolAccept = any;
type Utxo = any;
type MultisigInfo = any;
type EstimateSmartFee = any;
type DescriptorInfo = any;
type IndexInfo = any;
type FundedPsbt = any;
type Psbt = any;
type QueryOptions = any;
type Transaction = any;
type TransactionHistory = any;
type LabelBalance = any;
type AddressBalance = any;
type AddressGrouping = any;
type ImportMultiResult = any;
type PsbtOutput = any;
type ImportMultiOptions = any;
type ImportMultiRequest = any;
type AddressInfo = any;
type PsbtInput = any;
type SignRawTransactionInput = any;
type WalletFlag = any;
type PsbtBumpFeeOptions = any;
type ImportDescriptorsResult = any;
type TransactionInfo = any;
type Balances = any;
export declare class AbstractStandardRPCProvider {
    getBestBlockHash(): Promise<string>;
    getBlock(hash: string, verbose?: boolean): Promise<Block>;
    getBlockchainInfo(): Promise<BlockchainInfo>;
    getBlockCount(): Promise<number>;
    getBlockFilter(blockhash: string): Promise<BlockFilter>;
    getBlockHash(height: number): Promise<string>;
    getBlockHeader(hash: string, verbose?: boolean): Promise<BlockHeader>;
    getBlockStats(hashOrHeight: string | number): Promise<BlockStats>;
    getChainTips(): Promise<ChainTip[]>;
    getChainTxStats(nblocks?: number, blockhash?: string): Promise<ChainTxStats>;
    getDifficulty(): Promise<number>;
    getMempoolAncestors(txid: string, verbose?: boolean): Promise<MempoolAncestors>;
    getMempoolDescendants(txid: string, verbose?: boolean): Promise<MempoolDescendants>;
    getMempoolEntry(txid: string): Promise<MempoolEntry>;
    getMempoolInfo(): Promise<MempoolInfo>;
    getRawMempool(verbose?: boolean): Promise<RawMempool>;
    getRawTransaction(txid: string, verbose?: boolean): Promise<RawTransaction>;
    joinPsbts(...psbts: string[]): Promise<string>;
    sendRawTransaction(hex: string, maxfeerate?: number): Promise<string>;
    signRawTransactionWithKey(hex: string, keys: string[], utxos?: Utxo[], sighashtype?: string): Promise<SignedTransaction>;
    testMempoolAccept(...txs: string[]): Promise<TestMempoolAccept>;
    utxoUpdatePsbt(psbt: string, [utxos, bip32derivs]: [Utxo[], string[]]): Promise<string>;
    createMultisig(nrequired: number, keys: string[], addressType?: string): Promise<MultisigInfo>;
    deriveAddresses(descriptor: string, range: number[], isRange?: boolean): Promise<string[]>;
    estimateSmartFee(confTarget: number, mode?: string): Promise<EstimateSmartFee>;
    getDescriptorInfo(descriptor: string): Promise<DescriptorInfo>;
    getIndexInfo(index: string): Promise<IndexInfo>;
    signMessageWithPrivkey(privkey: string, message: string, compressed?: boolean): Promise<string>;
    validateAddress(address: string): Promise<ValidatedAddress>;
    verifyMessage(address: string, signature: string, message: string): Promise<boolean>;
    abandonTransaction(txid: string): Promise<void>;
    abortRescan(): Promise<void>;
    addMultisigAddress(nrequired: number, keys: string[], label?: string, addressType?: string): Promise<AddMultisigAddressResult>;
    backupWallet(destination: string): Promise<void>;
    bumpFee(txid: string, options?: BumpFeeOptions): Promise<BumpFeeResult>;
    createWallet(walletName: string, disablePrivateKeys?: boolean, blank?: boolean, passphrase?: string): Promise<void>;
    dumpPrivKey(address: string): Promise<string>;
    dumpWallet(filename: string): Promise<void>;
    encryptWallet(passphrase: string): Promise<void>;
    getAddressesByLabel(label: string): Promise<{
        [address: string]: string;
    }>;
    getAddressInfo(address: string): Promise<AddressInfo>;
    getBalance(account?: string, minconf?: number, includeWatchonly?: boolean): Promise<number>;
    getBalances(account?: string, minconf?: number, includeWatchonly?: boolean): Promise<Balances>;
    getNewAddress(label?: string, addressType?: string): Promise<string>;
    getRawChangeAddress(addressType?: string): Promise<string>;
    getReceivedByAddress(address: string, minconf?: number): Promise<number>;
    getReceivedByLabel(label: string, minconf?: number): Promise<number>;
    getTransaction(txid: string, includeWatchonly?: boolean): Promise<TransactionInfo>;
    getUnconfirmedBalance(): Promise<number>;
    getWalletInfo(): Promise<WalletInfo>;
    importAddress(address: string, label?: string, rescan?: boolean, p2sh?: boolean): Promise<void>;
    importDescriptors(descriptors: string[], range?: number, timestamp?: number): Promise<ImportDescriptorsResult>;
    importMulti(requests: ImportMultiRequest[], options?: ImportMultiOptions): Promise<ImportMultiResult>;
    importPrivKey(privkey: string, label?: string, rescan?: boolean): Promise<void>;
    importPrunedFunds(rawTransaction: string, txOutProof: string): Promise<void>;
    importPubKey(pubkey: string, label?: string, rescan?: boolean): Promise<void>;
    importWallet(filename: string): Promise<void>;
    keyPoolRefill(newsize?: number): Promise<void>;
    listAddressGroupings(): Promise<AddressGrouping[]>;
    listLabels(): Promise<string[]>;
    listLockUnspent(): Promise<Utxo[]>;
    listReceivedByAddress(minconf?: number, includeEmpty?: boolean, includeWatchonly?: boolean): Promise<AddressBalance[]>;
    listReceivedByLabel(minconf?: number, includeEmpty?: boolean, includeWatchonly?: boolean): Promise<LabelBalance[]>;
    listSinceBlock(blockhash?: string, targetConfirmations?: number, includeWatchonly?: boolean, includeRemoved?: boolean): Promise<TransactionHistory>;
    listTransactions(account?: string, count?: number, skip?: number, includeWatchonly?: boolean): Promise<Transaction[]>;
    listUnspent(minconf?: number, maxconf?: number, addresses?: string[], includeWatchonly?: boolean, queryOptions?: QueryOptions): Promise<Utxo[]>;
    listWalletDir(): Promise<string>;
    listWallets(): Promise<string[]>;
    loadWallet(filename: string): Promise<void>;
    lockUnspent(unlock: boolean, transactions: {
        txid: string;
        vout: number;
    }[]): Promise<boolean>;
    psbtBumpFee(psbt: string, options?: PsbtBumpFeeOptions): Promise<Psbt>;
    removePrunedFunds(txid: string): Promise<void>;
    rescanBlockchain(startHeight?: number, stopHeight?: number): Promise<void>;
    sendMany(fromAccount: string, amounts: {
        [address: string]: number;
    }, minconf?: number, comment?: string, subtractFeeFromAmount?: boolean, replaceable?: boolean, confTarget?: number, estimateMode?: string): Promise<string>;
    sendToAddress(address: string, amount: number, comment?: string, commentTo?: string, subtractFeeFromAmount?: boolean, replaceable?: boolean, confTarget?: number, estimateMode?: string): Promise<string>;
    setHdSeed(newkeypool?: boolean, seed?: string): Promise<void>;
    setLabel(address: string, label: string): Promise<void>;
    setTxFee(fee: number): Promise<boolean>;
    setWalletFlag(flag: WalletFlag): Promise<void>;
    signMessage(address: string, message: string): Promise<string>;
    signRawTransactionWithWallet(hexstring: string, inputs?: SignRawTransactionInput[], privkeys?: string[], sighashtype?: string): Promise<SignedTransaction>;
    unloadWallet(walletName: string): Promise<void>;
    upgradeWallet(walletName: string, upgradeToDescriptor: boolean): Promise<void>;
    walletCreateFundedPsbt(inputs: PsbtInput[], outputs: PsbtOutput[], locktime?: number, replaceable?: boolean): Promise<FundedPsbt>;
    walletLock(): Promise<void>;
    walletPassphrase(passphrase: string, timeout: number): Promise<void>;
    walletPassphraseChange(oldPassphrase: string, newPassphrase: string): Promise<void>;
    walletProcessPsbt(psbt: string, sign?: boolean, finalize?: boolean): Promise<ProcessedPsbt>;
    private throwNotImplementedError;
}
export {};
